<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Break-Even Tetris</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for Game Aesthetics */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');

        :root {
            --board-bg: #111827; /* Dark Slate Gray */
            --tile-size: 20px;
            --info-bg: #1f2937;
            --primary-color: #34d399; /* Emerald Green */
            --danger-color: #f87171; /* Red */
        }

        body {
            font-family: 'Chakra Petch', sans-serif;
            background-color: #0d121c;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-board {
            width: calc(10 * var(--tile-size));
            height: calc(20 * var(--tile-size));
            background: var(--board-bg);
            border: 4px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(52, 211, 153, 0.5);
        }

        #next-piece-display {
            width: calc(5 * var(--tile-size));
            height: calc(5 * var(--tile-size));
            background: var(--info-bg);
            border: 2px solid var(--primary-color);
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .piece-tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        /* Utility classes for financial display based on profitLoss */
        .profit-text {
            color: var(--primary-color);
            text-shadow: 0 0 5px rgba(52, 211, 153, 0.7);
        }

        .loss-text {
            color: var(--danger-color);
            text-shadow: 0 0 5px rgba(248, 113, 113, 0.7);
        }
        
        /* Button styling */
        .btn-game {
            background-color: var(--primary-color);
            color: #111827;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
            transition: transform 0.1s, background-color 0.1s;
        }

        .btn-game:hover {
            background-color: #10b981;
            transform: scale(1.02);
        }

        /* --- Quiz Modal Styles --- */
        #quiz-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none; /* Hidden by default */
            z-index: 100;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }

        #quiz-content {
            background-color: var(--info-bg);
            padding: 30px;
            border-radius: 12px;
            border: 3px solid var(--primary-color);
            box-shadow: 0 0 40px rgba(52, 211, 153, 0.7);
            max-width: 90%;
            text-align: center;
        }

        #quiz-message {
            margin-top: 15px;
            font-size: 0.9rem;
        }
        
        /* Custom button style for touch controls */
        .btn-control {
            background-color: var(--info-bg);
            color: var(--primary-color);
            font-weight: bold;
            border-radius: 8px;
            border: 2px solid var(--primary-color);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            transition: background-color 0.1s;
            user-select: none; /* Prevent text selection on touch */
            flex-grow: 1; /* Make buttons expand */
            margin: 4px;
            line-height: 1.25; /* Fix line height for better button fit */
            min-width: 60px; /* Ensure a minimum touch target size */
        }

        .btn-control:active {
            background-color: var(--primary-color);
            color: var(--info-bg);
            transform: translateY(2px);
            box-shadow: none;
        }
        
        /* Mobile adjustment for game board size */
        @media (max-width: 600px) {
            :root {
                --tile-size: 15px; /* Smaller tiles on mobile */
            }
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="flex flex-col lg:flex-row gap-6 p-4 bg-gray-900 rounded-xl shadow-2xl">
        
        <!-- Game Info Panel (Left/Top) -->
        <div class="w-full lg:w-1/3 p-4 bg-gray-800 rounded-lg shadow-inner">
            <h2 class="text-xl mb-4 text-primary-color">FINANCIAL DASHBOARD</h2>

            <!-- Score / Lines Cleared -->
             <div class="mb-4 p-3 bg-gray-700 rounded-md">
                <p class="text-sm text-gray-400">Total Lines Cleared:</p>
                <div id="lines-cleared-display" class="text-3xl font-bold text-white">0</div>
                <p id="quiz-progress" class="text-xs mt-1 text-primary-color font-mono">
                    Next Challenge in 10 lines
                </p>
            </div>

            <!-- Profit/Loss Display -->
            <div class="mb-4 p-3 bg-gray-700 rounded-md">
                <p class="text-sm text-gray-400">Profit / Loss (P = R - VC - FC):</p>
                <div id="profit-loss-display" class="text-3xl font-bold loss-text">
                    \$0
                </div>
                <p id="breakeven-status" class="text-xs mt-1 text-danger-color font-mono">
                    Breakeven: NOT REACHED
                </p>
            </div>
            
            <!-- Key Financial Metrics -->
            <div class="space-y-2 text-left text-sm">
                <p><span class="text-gray-400">Fixed Cost (FC):</span> <span id="fixed-cost-display" class="font-mono text-white">$500</span></p>
                <p><span class="text-gray-400">Selling Price per Line (R):</span> <span id="selling-price-display" class="font-mono text-white">$150</span></p>
                <p><span class="text-gray-400">Variable Cost per Block (VC):</span> <span id="variable-cost-display" class="font-mono text-white">$10</span></p>
                <p><span class="text-gray-400">Blocks Placed:</span> <span id="blocks-placed-display" class="font-mono text-white">0</span></p>
            </div>
            
            <div class="mt-6">
                <h3 class="text-lg text-primary-color mb-2">NEXT UNIT (VC)</h3>
                <div id="next-piece-display" class="mx-auto rounded-md">
                    <canvas id="next-canvas" width="100" height="100"></canvas>
                </div>
            </div>

            <button id="start-button" class="btn-game w-full mt-4">Start Game</button>
            <p id="game-message" class="mt-4 text-xs text-center text-primary-color"></p>
        </div>

        <!-- Game Board (Right/Center) -->
        <div class="w-full lg:w-2/3 flex flex-col items-center">
            <canvas id="game-board" width="200" height="400" class="rounded-lg mb-4"></canvas>
            
            <!-- Controls Hint -->
            <div class="text-center text-xs text-gray-500 mt-2 mb-4">
                Use Arrow Keys (←, →, ↓) to Move | (↑ or Space) to Rotate
            </div>

            <!-- Touch Controls for Mobile Users -->
            <div id="touch-controls" class="w-full max-w-sm p-2 mt-4 bg-gray-900 rounded-xl shadow-inner">
                <div class="flex justify-center mb-2">
                    <button id="btn-rotate" class="btn-control p-3 text-sm flex-1 max-w-xs">
                        ⟳ ROTATE
                    </button>
                </div>
                <div class="flex justify-between items-center">
                    <button id="btn-left" class="btn-control p-3 text-sm">
                        ← LEFT
                    </button>
                    <button id="btn-down" class="btn-control p-3 text-sm bg-danger-color hover:bg-red-700 border-danger-color">
                        ↓ DROP
                    </button>
                    <button id="btn-right" class="btn-control p-3 text-sm">
                        RIGHT →
                    </button>
                </div>
            </div>
        </div>

    </div>

    <!-- Quiz Modal -->
    <div id="quiz-modal">
        <div id="quiz-content" class="w-11/12 sm:w-2/3 md:w-1/2 lg:w-1/3">
            <h3 class="text-2xl font-bold text-primary-color mb-4">
                <span class="text-danger-color">CHALLENGE:</span> Financial Calculation
            </h3>
            <p id="quiz-question" class="text-lg mb-4 text-white"></p>
            <p class="text-sm text-gray-400 mb-2">Answer (Enter a whole number):</p>
            <input type="number" id="quiz-input" class="w-full p-2 mb-4 text-center text-xl rounded-md bg-gray-700 text-white focus:outline-none focus:ring-2 focus:ring-primary-color" placeholder="e.g., 500">
            
            <button id="submit-quiz" class="btn-game w-full">Submit Answer</button>
            
            <p id="quiz-message" class="text-center text-white"></p>
        </div>
    </div>


    <script>
        // --- GAME CONSTANTS ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20; // Must match --tile-size in CSS
        const INITIAL_SPEED = 1200; // ms (Increased from 1000 for easier gameplay)

        // --- FINANCIAL CONSTANTS (Breakeven Analysis) ---
        const FIXED_COST = 400; // Reduced from 500 for easier breakeven
        const SELLING_PRICE_PER_LINE = 160; // Increased from 150 for easier breakeven
        const VARIABLE_COST_PER_BLOCK = 10;
        const BLOCKS_PER_PIECE = 4;
        const QUIZ_FREQUENCY = 10; // Trigger quiz every 10 lines cleared
        const QUIZ_BONUS = 200; // Financial reward for a correct answer
        const MAX_LOSS_THRESHOLD = -700; // Bankruptcy if Profit/Loss drops below this

        // --- DERIVED FINANCIALS (Used for Quiz Answers) ---
        const VC_PER_LINE = VARIABLE_COST_PER_BLOCK * COLS; // $10 * 10 = $100
        const CM_PER_LINE = SELLING_PRICE_PER_LINE - VC_PER_LINE; // $160 - $100 = $60
        // Calculate BEP: $400 / $60 = 6.67 lines. Round up to 7 lines needed to cover costs.
        const BEP_IN_LINES = Math.ceil(FIXED_COST / CM_PER_LINE); // New BEP is 7 lines

        // --- GAME VARIABLES ---
        let board;
        let currentPiece;
        let nextPiece;
        let profitLoss;
        let blocksPlaced;
        let linesClearedTotal;
        let gameLoop;
        let isGameOver;
        let isPaused;
        let speed = INITIAL_SPEED;

        // --- Quiz Variables ---
        let currentQuizAnswer = 0;

        // --- DOM Elements ---
        const boardCanvas = document.getElementById('game-board');
        const nextCanvas = document.getElementById('next-canvas');
        const boardCtx = boardCanvas.getContext('2d');
        const nextCtx = nextCanvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const profitLossDisplay = document.getElementById('profit-loss-display');
        const breakevenStatus = document.getElementById('breakeven-status');
        const gameMessage = document.getElementById('game-message');
        const blocksPlacedDisplay = document.getElementById('blocks-placed-display');
        const linesClearedDisplay = document.getElementById('lines-cleared-display');
        const quizProgressDisplay = document.getElementById('quiz-progress');

        // Quiz DOM
        const quizModal = document.getElementById('quiz-modal');
        const quizQuestion = document.getElementById('quiz-question');
        const quizInput = document.getElementById('quiz-input');
        const quizSubmit = document.getElementById('submit-quiz');
        const quizMessage = document.getElementById('quiz-message');
        
        // Touch Control DOM
        const btnRotate = document.getElementById('btn-rotate');
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnDown = document.getElementById('btn-down');


        // Set canvas dimensions based on constants
        boardCanvas.width = COLS * BLOCK_SIZE;
        boardCanvas.height = ROWS * BLOCK_SIZE;
        boardCtx.scale(BLOCK_SIZE, BLOCK_SIZE);

        // --- TETRIS PIECE DATA (Standard J, L, I, O, S, Z, T) ---
        const PIECES = [
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I (Cyan)
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]], // J (Blue)
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]], // L (Orange)
            [[4, 4], [4, 4]], // O (Yellow)
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]], // S (Green)
            [[6, 6, 0], [0, 6, 6], [0, 0, 0]], // Z (Red)
            [[0, 7, 0], [7, 7, 7], [0, 0, 0]], // T (Purple)
        ];

        // Colors corresponding to piece index + 1
        const COLORS = [
            '#000000', // 0: Empty
            '#00FFFF', // 1: I - Cyan
            '#0000FF', // 2: J - Blue
            '#FFA500', // 3: L - Orange
            '#FFFF00', // 4: O - Yellow
            '#00FF00', // 5: S - Green
            '#FF0000', // 6: Z - Red
            '#800080', // 7: T - Purple
        ];

        // --- INITIALIZATION ---

        function initFinancials() {
            // Set initial state: Loss equals Fixed Costs
            profitLoss = -FIXED_COST;
            blocksPlaced = 0;
            linesClearedTotal = 0;

            // Update static displays
            document.getElementById('fixed-cost-display').textContent = `$${FIXED_COST}`;
            document.getElementById('selling-price-display').textContent = `$${SELLING_PRICE_PER_LINE}`;
            document.getElementById('variable-cost-display').textContent = `$${VARIABLE_COST_PER_BLOCK}`;
        }

        function initBoard() {
            // Create a 2D array representing the board, filled with 0s (empty)
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            isGameOver = false;
            isPaused = false;
            speed = INITIAL_SPEED;
            gameMessage.textContent = 'Use the arrow keys or touch controls to play.';
        }

        function drawSquare(ctx, x, y, colorIndex) {
            ctx.fillStyle = COLORS[colorIndex];
            ctx.fillRect(x, y, 1, 1);
            
            // Add grid/border effect
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1 / BLOCK_SIZE;
            ctx.strokeRect(x, y, 1, 1);
        }

        function drawBoard() {
            // Clear the board canvas
            boardCtx.clearRect(0, 0, COLS, ROWS);
            
            // Draw all locked pieces
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawSquare(boardCtx, c, r, board[r][c]);
                    }
                }
            }

            // Draw the current falling piece
            if (currentPiece) {
                currentPiece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            drawSquare(
                                boardCtx,
                                currentPiece.x + c,
                                currentPiece.y + r,
                                currentPiece.color
                            );
                        }
                    });
                });
            }
        }

        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            // Temporarily scale the next canvas context to draw pieces correctly
            nextCtx.save();
            nextCtx.scale(BLOCK_SIZE, BLOCK_SIZE);
            
            if (nextPiece) {
                 const startX = (5 - nextPiece.shape[0].length) / 2; // Center piece
                 const startY = (5 - nextPiece.shape.length) / 2;
                
                nextPiece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            drawSquare(
                                nextCtx,
                                startX + c,
                                startY + r,
                                nextPiece.color
                            );
                        }
                    });
                });
            }
            nextCtx.restore();
        }

        // --- PIECE LOGIC ---

        function createPiece() {
            const randomIndex = Math.floor(Math.random() * PIECES.length);
            return {
                shape: PIECES[randomIndex],
                color: randomIndex + 1,
                x: Math.floor(COLS / 2) - Math.floor(PIECES[randomIndex][0].length / 2),
                y: 0
            };
        }

        function spawnPiece() {
            if (!nextPiece) {
                nextPiece = createPiece();
            }
            currentPiece = nextPiece;
            nextPiece = createPiece();
            drawNextPiece();
            
            // Apply Variable Cost correctly (VC per block * 4 blocks per piece)
            profitLoss -= VARIABLE_COST_PER_BLOCK * BLOCKS_PER_PIECE;
            // Increment blocksPlaced by 4 (the actual number of blocks/units)
            blocksPlaced += BLOCKS_PER_PIECE;

            if (checkCollision(0, 0)) {
                gameOver('Stack reached the top!');
            }
        }

        function checkCollision(offsetX, offsetY, newShape = currentPiece.shape) {
            for (let r = 0; r < newShape.length; r++) {
                for (let c = 0; c < newShape[r].length; c++) {
                    if (newShape[r][c]) {
                        const newX = currentPiece.x + c + offsetX;
                        const newY = currentPiece.y + r + offsetY;

                        // Check boundaries
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true; // Wall or floor collision
                        }
                        
                        // Check if block already exists on the board (if within board limits)
                        if (newY >= 0 && board[newY] && board[newY][newX]) {
                            return true; // Existing block collision
                        }
                    }
                }
            }
            return false;
        }

        function movePiece(direction) {
            if (isGameOver || isPaused) return;

            const offsetX = (direction === 'left') ? -1 : (direction === 'right' ? 1 : 0);
            const offsetY = (direction === 'down') ? 1 : 0;

            if (!checkCollision(offsetX, offsetY)) {
                currentPiece.x += offsetX;
                currentPiece.y += offsetY;
            } else if (direction === 'down') {
                lockPiece();
            }
            drawBoard();
        }

        function rotatePiece() {
            if (isGameOver || isPaused) return;
            
            // Simple square matrix rotation clockwise
            const newShape = currentPiece.shape[0].map((_, colIndex) => 
                currentPiece.shape.map(row => row[colIndex]).reverse()
            );
            
            // Check collision with walls after rotation (No simple wall kick implemented)
            if (!checkCollision(0, 0, newShape)) {
                currentPiece.shape = newShape;
            }
            drawBoard();
        }

        function lockPiece() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        if (currentPiece.y + r < 0) {
                            gameOver('Stack reached the top!');
                            return;
                        }
                        board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                    }
                });
            });
            clearLines();
            // We spawn the next piece after clearing lines
            spawnPiece();
            drawBoard();
        }
        
        // --- CORE FINANCIAL/GAME LOGIC ---

        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                // Check if the row is full (contains no 0s)
                if (board[r].every(cell => cell !== 0)) {
                    // Line is full, generate revenue
                    linesCleared++;
                    
                    // Remove the full row and add a new empty row at the top
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    r++; // Check the new line at the current row index
                }
            }

            if (linesCleared > 0) {
                // Apply Revenue
                const revenueGained = linesCleared * SELLING_PRICE_PER_LINE;
                profitLoss += revenueGained;
                
                // Update total lines cleared and check for quiz trigger
                linesClearedTotal += linesCleared;
                checkQuizTrigger();

                // Increase speed for clearing lines (simulates scaling difficulty)
                // Reduced the speed increase factor from 10 to 5 for easier scaling
                speed = Math.max(50, speed - (5 * linesCleared)); 
                clearInterval(gameLoop);
                gameLoop = setInterval(dropPiece, speed);
            }
        }

        function checkQuizTrigger() {
            if (linesClearedTotal > 0 && linesClearedTotal % QUIZ_FREQUENCY === 0) {
                // Pause game and show quiz
                pauseGame(true); // Pause without changing button text
                showQuizModal();
            }
        }
        
        function updateFinancialDisplay() {
            const isLoss = profitLoss < 0;
            
            profitLossDisplay.textContent = `$${Math.abs(profitLoss).toFixed(0)}`;
            
            // Update Profit/Loss color and class
            profitLossDisplay.classList.remove('profit-text', 'loss-text');
            if (isLoss) {
                profitLossDisplay.classList.add('loss-text');
                // Ensure '-' sign is prepended correctly
                if (profitLossDisplay.firstChild?.nodeValue !== '-') {
                    profitLossDisplay.prepend(document.createTextNode('-'));
                }
            } else {
                profitLossDisplay.classList.add('profit-text');
            }

            // Update Breakeven Status
            if (isLoss) {
                breakevenStatus.textContent = 'Breakeven: NOT REACHED';
                breakevenStatus.classList.remove('profit-text');
                breakevenStatus.classList.add('loss-text');
            } else {
                breakevenStatus.textContent = 'Breakeven: ACHIEVED! (Profit)';
                breakevenStatus.classList.remove('loss-text');
                breakevenStatus.classList.add('profit-text');
            }

            // Check for Bankruptcy Game Over
            if (profitLoss < MAX_LOSS_THRESHOLD && !isGameOver) {
                gameOver('BANKRUPTCY: Net loss exceeded capital threshold!');
            }
            
            blocksPlacedDisplay.textContent = blocksPlaced;
            linesClearedDisplay.textContent = linesClearedTotal;
            quizProgressDisplay.textContent = `Next Challenge in ${QUIZ_FREQUENCY - (linesClearedTotal % QUIZ_FREQUENCY)} lines`;
        }

        // --- QUIZ LOGIC ---

        function generateQuiz() {
            const quizType = Math.random() < 0.5 ? 0 : 1; // 0 for CM, 1 for BEP

            if (quizType === 0) {
                // Contribution Margin (CM) Question
                quizQuestion.textContent = `CHALLENGE 1: What is the Contribution Margin per Line in dollars? (R per Line: $${SELLING_PRICE_PER_LINE}, VC per Line: $${VC_PER_LINE})`;
                currentQuizAnswer = CM_PER_LINE;
            } else {
                // Break-Even Point (BEP) Question
                quizQuestion.textContent = `CHALLENGE 2: How many Lines must be cleared to reach the Breakeven Point? (FC: $${FIXED_COST}, CM per Line: $${CM_PER_LINE})`;
                currentQuizAnswer = BEP_IN_LINES;
            }

            quizInput.value = '';
            quizMessage.textContent = 'Enter your financial calculation result.';
        }

        function showQuizModal() {
            generateQuiz();
            quizModal.style.display = 'flex';
        }

        function checkQuizAnswer() {
            const userAnswer = parseInt(quizInput.value, 10);
            
            if (isNaN(userAnswer)) {
                quizMessage.textContent = 'Please enter a valid number.';
                return;
            }

            if (userAnswer === currentQuizAnswer) {
                // Success!
                profitLoss += QUIZ_BONUS;
                updateFinancialDisplay();
                quizMessage.innerHTML = `<span class="profit-text font-bold">CORRECT!</span> You earned a $${QUIZ_BONUS} bonus.`;
                quizInput.disabled = true;
                quizSubmit.textContent = 'Continue Game';
                quizSubmit.onclick = () => {
                    quizModal.style.display = 'none';
                    quizInput.disabled = false;
                    quizSubmit.textContent = 'Submit Answer';
                    quizSubmit.onclick = checkQuizAnswer; // Reset handler
                    resumeGame();
                };
            } else {
                // Failure
                quizMessage.innerHTML = '<span class="loss-text font-bold">INCORRECT.</span> Review the formula and try again.';
            }
        }


        // --- GAME FLOW ---

        function dropPiece() {
            if (isGameOver || isPaused) return;

            if (!checkCollision(0, 1)) {
                currentPiece.y++;
            } else {
                lockPiece();
            }
            drawBoard();
            updateFinancialDisplay(); // Update display on every drop
        }
        
        function startGame() {
            if (gameLoop) clearInterval(gameLoop);
            
            initFinancials();
            initBoard();
            
            // Reset button text and handler
            startButton.textContent = 'Pause Game';
            startButton.onclick = () => pauseGame(false); 
            gameMessage.textContent = 'Game Running. Current Speed: 1.0x';

            spawnPiece(); // Start the first piece drop
            gameLoop = setInterval(dropPiece, speed);
            updateFinancialDisplay();
        }

        function pauseGame(isExternalPause = false) {
            isPaused = true;
            clearInterval(gameLoop);

            if (!isExternalPause) {
                startButton.textContent = 'Resume Game';
                startButton.onclick = resumeGame;
                gameMessage.textContent = 'PAUSED.';
            }
        }

        function resumeGame() {
            isPaused = false;
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(dropPiece, speed);
            
            // Reset button and message
            startButton.textContent = 'Pause Game';
            startButton.onclick = () => pauseGame(false);
            gameMessage.textContent = `Game Running. Current Speed: ${(INITIAL_SPEED/speed).toFixed(1)}x`;
        }

        function gameOver(reason) {
            isGameOver = true;
            clearInterval(gameLoop);
            gameMessage.innerHTML = `<span class="loss-text font-bold">GAME OVER</span>: ${reason}`;
            startButton.textContent = 'Restart Analysis';
            startButton.onclick = startGame;
            
            // Show final message
            if (profitLoss >= 0) {
                 gameMessage.innerHTML += '<br><span class="profit-text">You achieved Breakeven!</span>';
            } else {
                 gameMessage.innerHTML += '<br><span class="loss-text">Failed to cover Fixed Costs.</span>';
            }
        }
        
        // --- TOUCH CONTROL SETUP ---
        function setupTouchControls() {
            // Helper function to prevent default touch/drag behavior
            const preventDefaults = (e) => {
                e.preventDefault();
                e.stopPropagation();
            };

            // Attach event listeners for touch and click
            btnRotate.addEventListener('touchstart', (e) => { preventDefaults(e); rotatePiece(); }, { passive: false });
            btnRotate.addEventListener('click', rotatePiece);

            btnLeft.addEventListener('touchstart', (e) => { preventDefaults(e); movePiece('left'); }, { passive: false });
            btnLeft.addEventListener('click', () => movePiece('left'));

            btnRight.addEventListener('touchstart', (e) => { preventDefaults(e); movePiece('right'); }, { passive: false });
            btnRight.addEventListener('click', () => movePiece('right'));

            btnDown.addEventListener('touchstart', (e) => { preventDefaults(e); movePiece('down'); }, { passive: false });
            btnDown.addEventListener('click', () => movePiece('down'));
        }


        // --- EVENT LISTENERS ---

        document.addEventListener('keydown', (e) => {
            if (isGameOver || isPaused || quizModal.style.display === 'flex') return;

            if (currentPiece) {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        movePiece('left');
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        movePiece('right');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        movePiece('down');
                        break;
                    case 'ArrowUp':
                    case ' ': // Space bar for rotate
                        e.preventDefault();
                        rotatePiece();
                        break;
                }
            }
        });

        // Quiz Submit Listener
        quizSubmit.onclick = checkQuizAnswer;
        quizInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                checkQuizAnswer();
            }
        });
        
        startButton.onclick = startGame;
        
        // Initial setup for static displays
        document.addEventListener('DOMContentLoaded', () => {
             initFinancials();
             initBoard();
             drawBoard();
             drawNextPiece();
             updateFinancialDisplay();
             setupTouchControls(); // Initialize touch controls
        });

    </script>
</body>
</html>
