<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Break-Even Tetris</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for Game Aesthetics */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');

        :root {
            --board-bg: #111827; /* Dark Slate Gray */
            --tile-size: 20px;
            --info-bg: #1f2937;
            --primary-color: #34d399; /* Emerald Green */
            --danger-color: #f87171; /* Red */
        }

        body {
            font-family: 'Chakra Petch', sans-serif;
            background-color: #0d121c;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #game-board {
            width: calc(10 * var(--tile-size));
            height: calc(20 * var(--tile-size));
            background: var(--board-bg);
            border: 4px solid var(--primary-color);
            box-shadow: 0 0 20px rgba(52, 211, 153, 0.5);
        }

        #next-piece-display {
            width: calc(5 * var(--tile-size));
            height: calc(5 * var(--tile-size));
            background: var(--info-bg);
            border: 2px solid var(--primary-color);
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .piece-tile {
            position: absolute;
            width: var(--tile-size);
            height: var(--tile-size);
            border: 1px solid rgba(0, 0, 0, 0.2);
            box-shadow: inset 0 0 5px rgba(255, 255, 255, 0.3);
        }

        /* Utility classes for financial display based on profitLoss */
        .profit-text {
            color: var(--primary-color);
            text-shadow: 0 0 5px rgba(52, 211, 153, 0.7);
        }

        .loss-text {
            color: var(--danger-color);
            text-shadow: 0 0 5px rgba(248, 113, 113, 0.7);
        }
        
        /* Button styling */
        .btn-game {
            background-color: var(--primary-color);
            color: #111827;
            font-weight: bold;
            padding: 10px 20px;
            border-radius: 8px;
            transition: transform 0.1s, background-color 0.1s;
        }

        .btn-game:hover {
            background-color: #10b981;
            transform: scale(1.02);
        }
        
        /* Mobile adjustment for game board size */
        @media (max-width: 600px) {
            :root {
                --tile-size: 15px; /* Smaller tiles on mobile */
            }
        }
    </style>
</head>
<body class="p-4">

    <div id="app" class="flex flex-col lg:flex-row gap-6 p-4 bg-gray-900 rounded-xl shadow-2xl">
        
        <!-- Game Info Panel (Left/Top) -->
        <div class="w-full lg:w-1/3 p-4 bg-gray-800 rounded-lg shadow-inner">
            <h2 class="text-xl mb-4 text-primary-color">FINANCIAL DASHBOARD</h2>

            <!-- Profit/Loss Display -->
            <div class="mb-4 p-3 bg-gray-700 rounded-md">
                <p class="text-sm text-gray-400">Profit / Loss (P = R - VC - FC):</p>
                <div id="profit-loss-display" class="text-3xl font-bold loss-text">
                    \$0
                </div>
                <p id="breakeven-status" class="text-xs mt-1 text-danger-color font-mono">
                    Breakeven: NOT REACHED
                </p>
            </div>
            
            <!-- Key Financial Metrics -->
            <div class="space-y-2 text-left text-sm">
                <p><span class="text-gray-400">Fixed Cost (FC):</span> <span id="fixed-cost-display" class="font-mono text-white">$500</span></p>
                <p><span class="text-gray-400">Selling Price per Line (R):</span> <span id="selling-price-display" class="font-mono text-white">$100</span></p>
                <p><span class="text-gray-400">Variable Cost per Block (VC):</span> <span id="variable-cost-display" class="font-mono text-white">$10</span></p>
                <p><span class="text-gray-400">Blocks Placed:</span> <span id="blocks-placed-display" class="font-mono text-white">0</span></p>
            </div>
            
            <div class="mt-6">
                <h3 class="text-lg text-primary-color mb-2">NEXT UNIT (VC)</h3>
                <div id="next-piece-display" class="mx-auto rounded-md">
                    <canvas id="next-canvas" width="100" height="100"></canvas>
                </div>
            </div>

            <button id="start-button" class="btn-game w-full mt-4">Start Game</button>
            <p id="game-message" class="mt-4 text-xs text-center text-primary-color"></p>
        </div>

        <!-- Game Board (Right/Center) -->
        <div class="w-full lg:w-2/3 flex flex-col items-center">
            <canvas id="game-board" width="200" height="400" class="rounded-lg mb-4"></canvas>
            
            <!-- Controls Hint -->
            <div class="text-center text-xs text-gray-500 mt-2">
                Use Arrow Keys (←, →, ↓) to Move | (↑ or Space) to Rotate
            </div>
        </div>

    </div>

    <script>
        // --- GAME CONSTANTS ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20; // Must match --tile-size in CSS
        const INITIAL_SPEED = 1000; // ms

        // --- FINANCIAL CONSTANTS (Breakeven Analysis) ---
        const FIXED_COST = 500;
        const SELLING_PRICE_PER_LINE = 100;
        const VARIABLE_COST_PER_BLOCK = 10;
        const MAX_LOSS_THRESHOLD = -700; // Bankruptcy if Profit/Loss drops below this

        // --- GAME VARIABLES ---
        let board;
        let currentPiece;
        let nextPiece;
        let profitLoss;
        let blocksPlaced;
        let gameLoop;
        let isGameOver;
        let isPaused;
        let speed = INITIAL_SPEED;

        // --- DOM Elements ---
        const boardCanvas = document.getElementById('game-board');
        const nextCanvas = document.getElementById('next-canvas');
        const boardCtx = boardCanvas.getContext('2d');
        const nextCtx = nextCanvas.getContext('2d');
        const startButton = document.getElementById('start-button');
        const profitLossDisplay = document.getElementById('profit-loss-display');
        const breakevenStatus = document.getElementById('breakeven-status');
        const gameMessage = document.getElementById('game-message');
        const blocksPlacedDisplay = document.getElementById('blocks-placed-display');

        // Set canvas dimensions based on constants
        boardCanvas.width = COLS * BLOCK_SIZE;
        boardCanvas.height = ROWS * BLOCK_SIZE;
        boardCtx.scale(BLOCK_SIZE, BLOCK_SIZE);

        // --- TETRIS PIECE DATA (Standard J, L, I, O, S, Z, T) ---
        const PIECES = [
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I (Cyan)
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]], // J (Blue)
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]], // L (Orange)
            [[4, 4], [4, 4]], // O (Yellow)
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]], // S (Green)
            [[6, 6, 0], [0, 6, 6], [0, 0, 0]], // Z (Red)
            [[0, 7, 0], [7, 7, 7], [0, 0, 0]], // T (Purple)
        ];

        // Colors corresponding to piece index + 1
        const COLORS = [
            '#000000', // 0: Empty
            '#00FFFF', // 1: I - Cyan
            '#0000FF', // 2: J - Blue
            '#FFA500', // 3: L - Orange
            '#FFFF00', // 4: O - Yellow
            '#00FF00', // 5: S - Green
            '#FF0000', // 6: Z - Red
            '#800080', // 7: T - Purple
        ];

        // --- INITIALIZATION ---

        function initFinancials() {
            // Set initial state: Loss equals Fixed Costs
            profitLoss = -FIXED_COST;
            blocksPlaced = 0;

            // Update static displays
            document.getElementById('fixed-cost-display').textContent = `$${FIXED_COST}`;
            document.getElementById('selling-price-display').textContent = `$${SELLING_PRICE_PER_LINE}`;
            document.getElementById('variable-cost-display').textContent = `$${VARIABLE_COST_PER_BLOCK}`;
        }

        function initBoard() {
            // Create a 2D array representing the board, filled with 0s (empty)
            board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            isGameOver = false;
            isPaused = false;
            speed = INITIAL_SPEED;
            gameMessage.textContent = 'Use the arrow keys to play.';
        }

        function drawSquare(ctx, x, y, colorIndex) {
            ctx.fillStyle = COLORS[colorIndex];
            ctx.fillRect(x, y, 1, 1);
            
            // Add grid/border effect
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 1 / BLOCK_SIZE;
            ctx.strokeRect(x, y, 1, 1);
        }

        function drawBoard() {
            // Clear the board canvas
            boardCtx.clearRect(0, 0, COLS, ROWS);
            
            // Draw all locked pieces
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawSquare(boardCtx, c, r, board[r][c]);
                    }
                }
            }

            // Draw the current falling piece
            if (currentPiece) {
                currentPiece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            drawSquare(
                                boardCtx,
                                currentPiece.x + c,
                                currentPiece.y + r,
                                currentPiece.color
                            );
                        }
                    });
                });
            }
        }

        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            // Temporarily scale the next canvas context to draw pieces correctly
            nextCtx.save();
            nextCtx.scale(BLOCK_SIZE, BLOCK_SIZE);
            
            if (nextPiece) {
                 const startX = (5 - nextPiece.shape[0].length) / 2; // Center piece
                 const startY = (5 - nextPiece.shape.length) / 2;
                
                nextPiece.shape.forEach((row, r) => {
                    row.forEach((cell, c) => {
                        if (cell) {
                            drawSquare(
                                nextCtx,
                                startX + c,
                                startY + r,
                                nextPiece.color
                            );
                        }
                    });
                });
            }
            nextCtx.restore();
        }

        // --- PIECE LOGIC ---

        function createPiece() {
            const randomIndex = Math.floor(Math.random() * PIECES.length);
            return {
                shape: PIECES[randomIndex],
                color: randomIndex + 1,
                x: Math.floor(COLS / 2) - Math.floor(PIECES[randomIndex][0].length / 2),
                y: 0
            };
        }

        function spawnPiece() {
            if (!nextPiece) {
                nextPiece = createPiece();
            }
            currentPiece = nextPiece;
            nextPiece = createPiece();
            drawNextPiece();
            
            // Apply Variable Cost
            profitLoss -= VARIABLE_COST_PER_BLOCK;
            blocksPlaced++;

            if (checkCollision(0, 0)) {
                gameOver('Stack reached the top!');
            }
        }

        function checkCollision(offsetX, offsetY, newShape = currentPiece.shape) {
            for (let r = 0; r < newShape.length; r++) {
                for (let c = 0; c < newShape[r].length; c++) {
                    if (newShape[r][c]) {
                        const newX = currentPiece.x + c + offsetX;
                        const newY = currentPiece.y + r + offsetY;

                        // Check boundaries
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true; // Wall or floor collision
                        }
                        
                        // Check if block already exists on the board (if within board limits)
                        if (newY >= 0 && board[newY] && board[newY][newX]) {
                            return true; // Existing block collision
                        }
                    }
                }
            }
            return false;
        }

        function movePiece(direction) {
            if (isGameOver || isPaused) return;

            const offsetX = (direction === 'left') ? -1 : (direction === 'right' ? 1 : 0);
            const offsetY = (direction === 'down') ? 1 : 0;

            if (!checkCollision(offsetX, offsetY)) {
                currentPiece.x += offsetX;
                currentPiece.y += offsetY;
            } else if (direction === 'down') {
                lockPiece();
            }
            drawBoard();
        }

        function rotatePiece() {
            if (isGameOver || isPaused) return;
            
            // Simple square matrix rotation clockwise
            const newShape = currentPiece.shape[0].map((_, colIndex) => 
                currentPiece.shape.map(row => row[colIndex]).reverse()
            );
            
            // Check collision with walls after rotation (No simple wall kick implemented)
            if (!checkCollision(0, 0, newShape)) {
                currentPiece.shape = newShape;
            }
            drawBoard();
        }

        function lockPiece() {
            currentPiece.shape.forEach((row, r) => {
                row.forEach((cell, c) => {
                    if (cell) {
                        if (currentPiece.y + r < 0) {
                            gameOver('Stack reached the top!');
                            return;
                        }
                        board[currentPiece.y + r][currentPiece.x + c] = currentPiece.color;
                    }
                });
            });
            clearLines();
            spawnPiece();
            drawBoard();
        }
        
        // --- CORE FINANCIAL/GAME LOGIC ---

        function clearLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                // Check if the row is full (contains no 0s)
                if (board[r].every(cell => cell !== 0)) {
                    // Line is full, generate revenue
                    linesCleared++;
                    
                    // Remove the full row and add a new empty row at the top
                    board.splice(r, 1);
                    board.unshift(Array(COLS).fill(0));
                    r++; // Check the new line at the current row index
                }
            }

            if (linesCleared > 0) {
                // Calculate Revenue and update Profit/Loss
                const revenueGained = linesCleared * SELLING_PRICE_PER_LINE;
                profitLoss += revenueGained;
                
                // Increase speed for clearing lines (simulates scaling difficulty)
                speed = Math.max(50, speed - (10 * linesCleared)); 
                clearInterval(gameLoop);
                gameLoop = setInterval(dropPiece, speed);
            }
        }
        
        function updateFinancialDisplay() {
            const isLoss = profitLoss < 0;
            
            profitLossDisplay.textContent = `$${Math.abs(profitLoss).toFixed(0)}`;
            
            // Update Profit/Loss color and class
            profitLossDisplay.classList.remove('profit-text', 'loss-text');
            if (isLoss) {
                profitLossDisplay.classList.add('loss-text');
                profitLossDisplay.prepend(document.createTextNode('-'));
            } else {
                profitLossDisplay.classList.add('profit-text');
            }

            // Update Breakeven Status
            if (isLoss) {
                breakevenStatus.textContent = 'Breakeven: NOT REACHED';
                breakevenStatus.classList.remove('profit-text');
                breakevenStatus.classList.add('loss-text');
            } else {
                breakevenStatus.textContent = 'Breakeven: ACHIEVED! (Profit)';
                breakevenStatus.classList.remove('loss-text');
                breakevenStatus.classList.add('profit-text');
            }

            // Check for Bankruptcy Game Over
            if (profitLoss < MAX_LOSS_THRESHOLD && !isGameOver) {
                gameOver('BANKRUPTCY: Net loss exceeded capital threshold!');
            }
            
            blocksPlacedDisplay.textContent = blocksPlaced;
        }


        // --- GAME FLOW ---

        function dropPiece() {
            if (isGameOver || isPaused) return;

            if (!checkCollision(0, 1)) {
                currentPiece.y++;
            } else {
                lockPiece();
            }
            drawBoard();
            updateFinancialDisplay(); // Update display on every drop
        }
        
        function startGame() {
            if (gameLoop) clearInterval(gameLoop);
            
            initFinancials();
            initBoard();
            
            // Reset button text
            startButton.textContent = 'Pause Game';
            startButton.onclick = pauseGame;
            gameMessage.textContent = 'Game Running. Current Speed: 1.0x';

            spawnPiece(); // Start the first piece drop
            gameLoop = setInterval(dropPiece, speed);
            updateFinancialDisplay();
        }

        function pauseGame() {
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(gameLoop);
                startButton.textContent = 'Resume Game';
                gameMessage.textContent = 'PAUSED. Costs still apply when not playing... (just kidding, it\'s paused).';
            } else {
                gameLoop = setInterval(dropPiece, speed);
                startButton.textContent = 'Pause Game';
                gameMessage.textContent = `Game Running. Current Speed: ${(INITIAL_SPEED/speed).toFixed(1)}x`;
            }
        }

        function gameOver(reason) {
            isGameOver = true;
            clearInterval(gameLoop);
            gameMessage.innerHTML = `<span class="loss-text font-bold">GAME OVER</span>: ${reason}`;
            startButton.textContent = 'Restart Analysis';
            startButton.onclick = startGame;
            
            // Show final message
            if (profitLoss >= 0) {
                 gameMessage.innerHTML += '<br><span class="profit-text">You achieved Breakeven!</span>';
            } else {
                 gameMessage.innerHTML += '<br><span class="loss-text">Failed to cover Fixed Costs.</span>';
            }
        }

        // --- EVENT LISTENERS ---

        document.addEventListener('keydown', (e) => {
            if (isGameOver || isPaused) return;

            if (currentPiece) {
                switch (e.key) {
                    case 'ArrowLeft':
                        e.preventDefault();
                        movePiece('left');
                        break;
                    case 'ArrowRight':
                        e.preventDefault();
                        movePiece('right');
                        break;
                    case 'ArrowDown':
                        e.preventDefault();
                        movePiece('down');
                        break;
                    case 'ArrowUp':
                    case ' ': // Space bar for rotate
                        e.preventDefault();
                        rotatePiece();
                        break;
                }
            }
        });
        
        startButton.onclick = startGame;
        
        // Initial setup for static displays
        document.addEventListener('DOMContentLoaded', () => {
             initFinancials();
             initBoard();
             drawBoard();
             drawNextPiece();
             updateFinancialDisplay();
        });

    </script>
</body>
</html>
